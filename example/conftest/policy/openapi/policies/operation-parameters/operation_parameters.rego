package openapi.policies["operation-parameters"]

import data.openapi.lib

# METADATA
# {"scope":"rule","title":"operation-parameters","description":"Operation parameters are unique and non-repeating."}
results[lib.format_msg(rego.metadata.rule(), path, message)] { assign(op, input.paths[p][m]); lib.is_method_valid(m); assign(path_parent, ["paths", p, m, "parameters"]); assign(params, op.parameters); is_array(params); gt(count(params), 1); assign(dupes, dupe_results(params, path_parent)); assign(collisions, body_formdata_collision_results(params, path_parent)); assign(ensured_body_params, ensure_one_body_param_results(params, path_parent)); assign(all_results, or(or(dupes, collisions), ensured_body_params)); all_results[[path, message]] }
dupe_results(params, path_parent) := dupe_results { assign(dupes, union({{i1, i2} | equal(params[i1].name, params[i2].name); equal(params[i1].in, params[i2].in); not equal(i1, i2)})); assign(dupe_results, {[dp, dm] | assign(dm, "A parameter in this operation already exposes the same combination of \"name\" and \"in\" values."); dupes[i]; assign(dp, array.concat(path_parent, [sprintf("%d", [i])]))}) }
body_formdata_collision_results(params, path) := collision_results { assign(msg, "Operation must not have both \"in:body\" and \"in:formData\" parameters."); assign(collision_results, {[p, m] | assign(body_count, [i | equal(params[i].in, "body")]); assign(formdata_count, [i | equal(params[i].in, "formData")]); gt(count(body_count), 0); gt(count(formdata_count), 0); assign(p, path); assign(m, msg)}) }
ensure_one_body_param_results(params, path_parent) := ensured_body_param_results { assign(msg, "Operation must not have more than a single instance of the \"in:body\" parameter."); ensured_body_param_results = {[p, m] | assign(body_count, [i | equal(params[i].in, "body")]); gt(count(body_count), 1); assign(i, body_count[_]); assign(p, array.concat(path_parent, [sprintf("%d", [i])])); assign(m, msg)} }